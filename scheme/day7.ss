;; day 7 
(load "util.ss")

(define (parse-data str) 
  (define xs (string-split str " "))
  (cons (list-ref xs 1) (list-ref xs 7)))

(define data (map parse-data (get-lines "../data/input7.txt")))

(define (make-blocklist)
  (define blocks (make-hashtable string-hash string=?))
  (define (add-block p)
    (hashtable-update! blocks (cdr p) (lambda (x) (cons (car p) x)) '()))
  (map add-block data)
  blocks)

(define (find-available xs)
  (define available (make-hashtable string-hash string=?))
  (define (add e)
    (hashtable-set! available (car e) #t)
    (hashtable-set! available (cdr e) #t))
  (for-each add xs)
  (list-sort string<? (vector->list (hashtable-keys available))))

(define (remove-block blocks c)
  (vector-for-each (lambda (k) 
        (hashtable-update! blocks k (lambda(xs) (remove c xs)) '())) (hashtable-keys blocks)))

(define (solve)
  (define blocks (make-blocklist))
  (define (worker left acc)
    (if (null? left)
      (reverse acc)
      (let ((unblocked (find (lambda (n) (null? (hashtable-ref blocks n '()))) left)))
        (if unblocked
          (begin
            (remove-block blocks unblocked)
            (worker (remove unblocked left) (cons unblocked acc)))
          #f))))
  (fold-left string-append "" (worker (find-available data) '())))

(define-record-type elf (fields (mutable task) (mutable time)) (nongenerative))

(define (solve2)
  (define elves (map (lambda (x) (make-elf #f 0)) '(0 0 0 0 0)))
  (define blocks (make-blocklist))
  (define (allocate-tasks ws ts)
    (let loop ((w ws) (t ts) (alloc '()))
      (if (not (or (null? w) (null? t)))
        (begin
          (elf-task-set! (car w) (car t))
          (elf-time-set! (car w) (- (char->integer (string-ref (car t) 0)) 4))
          (loop (cdr w) (cdr t) (cons (car t) alloc)))
        alloc)))
  (define (update-tasks)
    (define (update-task fini e)
      (elf-time-set! e (- (elf-time e) 1))
      (if (and (elf-task e) (= (elf-time e) 0))
        (let ((new-fini (cons (string-copy (elf-task e)) fini)))
          (remove-block blocks (elf-task e))
          (elf-task-set! e #f)
          new-fini)
        fini))
    (fold-left update-task '() elves))
  (let loop ((t 0) (left (find-available data)) (available (find-available data)))
    (if (null? left)
      t
      (let* ((free-elves (filter (lambda (e) (not (elf-task e))) elves))
             (unblocked-tasks (filter (lambda (n) (null? (hashtable-ref blocks n '()))) available))
             (allocated (allocate-tasks free-elves unblocked-tasks))
             (completed (update-tasks))
             (new-left (filter (lambda (t) (not (member t completed))) left))
             (new-available (filter (lambda (t) (not (member t allocated))) available)))
          (loop (+ t 1) new-left new-available)))))

(display (solve)) (display "  ") (display (solve2))